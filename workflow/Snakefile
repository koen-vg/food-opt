# SPDX-FileCopyrightText: 2025 Koen van Greevenbroek
#
# SPDX-License-Identifier: GPL-3.0-or-later

import csv
import itertools
import os
from pathlib import Path

from snakemake.logging import logger
from snakemake.utils import min_version

from validation import validate as run_validations

min_version("9.0")

os.makedirs("data/downloads", exist_ok=True)


configfile: "config/default.yaml"


PROJECT_ROOT = Path.cwd()


def _validate_inputs() -> None:
    """Run repo-level validation before Snakemake resolves rules."""

    logger.info("Validating configuration and input datasets")
    run_validations(config, project_root=PROJECT_ROOT)


_validate_inputs()


# Include common configuration and helper functions first
include: "rules/common.smk"
include: "rules/retrieve.smk"
include: "rules/plotting.smk"
include: "rules/yield_gaps.smk"
include: "rules/luc.smk"
include: "rules/documentation.smk"


wildcard_constraints:
    climate_model=r"[a-zA-Z0-9\-]+",
    period=r"[A-Z0-9]+",
    scenario=r"[A-Z0-9]+",
    input_level=r"H|L",
    water_supply=r"[ri]",
    crop=r"[a-zA-Z0-9\-]+",
    item=r"[a-zA-Z0-9_-]+",


ALL_RULE_TARGETS = [
    "results/{name}/solved/model.nc",
    # results plots
    "results/{name}/plots/crop_production.pdf",
    "results/{name}/plots/resource_usage.pdf",
    "results/{name}/plots/crop_production.csv",
    "results/{name}/plots/food_production.csv",
    "results/{name}/plots/objective_breakdown.pdf",
    "results/{name}/plots/objective_breakdown.csv",
    "results/{name}/plots/emissions_breakdown.pdf",
    "results/{name}/plots/health_risk_map.pdf",
    "results/{name}/plots/health_risk_by_region.csv",
    "results/{name}/plots/health_baseline_map.pdf",
    "results/{name}/plots/health_baseline_by_region.csv",
    # maps
    "results/{name}/plots/regions_map.pdf",
    "results/{name}/plots/resource_classes_map.pdf",
    "results/{name}/plots/crop_production_map.pdf",
    "results/{name}/plots/crop_land_use_map.pdf",
    "results/{name}/plots/cropland_fraction_map.pdf",
    "results/{name}/plots/irrigated_cropland_fraction_map.pdf",
    "results/{name}/plots/crop_use_breakdown.pdf",
    "results/{name}/plots/crop_use_breakdown.csv",
    # "results/{name}/plots/water_value_map.pdf",   # Current not working (see issue #1)
    "results/{name}/plots/food_consumption.pdf",
    "results/{name}/plots/food_consumption_map.pdf",
    "results/{name}/plots/food_consumption_baseline_map.pdf",
]


rule all:
    input:
        expand(ALL_RULE_TARGETS, name=[name]),


rule prepare_population:
    input:
        population_gz="data/downloads/WPP_population.csv.gz",
    params:
        planning_horizon=config["planning_horizon"],
        countries=config["countries"],
        health_reference_year=config["health"]["reference_year"],
    output:
        population="processing/{name}/population.csv",
        population_age="processing/{name}/population_age.csv",
    log:
        "logs/{name}/prepare_population.log",
    script:
        "scripts/prepare_population.py"


rule simplify_gadm:
    input:
        "data/downloads/gadm.gpkg",
    params:
        simplify_min_area_km=config["aggregation"]["simplify_min_area_km"],
        simplify_tolerance_km=config["aggregation"]["simplify_tolerance_km"],
    output:
        "processing/shared/gadm-simplified.gpkg",
    log:
        "logs/shared/simplify_gadm.log",
    script:
        "scripts/simplify_gadm.py"


rule prepare_fao_edible_portion:
    input:
        table="data/downloads/fao_nutrient_conversion_table_for_sua_2024.xlsx",
        mapping="data/faostat_item_map.csv",
    params:
        crops=config["crops"],
    output:
        edible_portion="processing/{name}/fao_edible_portion.csv",
    log:
        "logs/{name}/prepare_fao_edible_portion.log",
    script:
        "scripts/prepare_fao_edible_portion.py"


rule prepare_gleam_feed_properties:
    input:
        gleam_supplement="data/downloads/gleam_3.0_supplement_s1.xlsx",
        gleam_mapping="data/gleam_feed_mapping.csv",
    output:
        ruminant="processing/{name}/ruminant_feed_properties.csv",
        monogastric="processing/{name}/monogastric_feed_properties.csv",
    log:
        "logs/{name}/prepare_gleam_feed_properties.log",
    script:
        "scripts/prepare_gleam_feed_properties.py"


rule prepare_fertilizer_application_rates:
    input:
        fubc_data="data/downloads/ifa_fubc_1_to_9_data.csv",
        mapping="data/ifa_fubc_crop_mapping.csv",
    output:
        "processing/{name}/fertilizer_application_rates.csv",
    log:
        "logs/{name}/prepare_fertilizer_application_rates.log",
    script:
        "scripts/prepare_fertilizer_application_rates.py"


rule derive_global_fertilizer_rates:
    input:
        fertilizer_rates="processing/{name}/fertilizer_application_rates.csv",
    params:
        n_percentile=config["primary"]["fertilizer"]["n_percentile"],
        crops=config["crops"],
    output:
        "processing/{name}/global_fertilizer_n_rates.csv",
    log:
        "logs/{name}/derive_global_fertilizer_rates.log",
    script:
        "scripts/derive_global_fertilizer_rates.py"


rule categorize_feeds:
    input:
        ruminant_feed_properties="processing/{name}/ruminant_feed_properties.csv",
        monogastric_feed_properties="processing/{name}/monogastric_feed_properties.csv",
        enteric_methane_yields="data/ipcc_enteric_methane_yields.csv",
        ash_content="data/feed_ash_content.csv",
    output:
        ruminant_categories="processing/{name}/ruminant_feed_categories.csv",
        monogastric_categories="processing/{name}/monogastric_feed_categories.csv",
        ruminant_mapping="processing/{name}/ruminant_feed_mapping.csv",
        monogastric_mapping="processing/{name}/monogastric_feed_mapping.csv",
    log:
        "logs/{name}/categorize_feeds.log",
    script:
        "scripts/categorize_feeds.py"


rule build_feed_to_animal_products:
    input:
        wirsenius="data/wirsenius_feed_energy_requirements.csv",
        ruminant_categories="processing/{name}/ruminant_feed_categories.csv",
        monogastric_categories="processing/{name}/monogastric_feed_categories.csv",
    output:
        "processing/{name}/feed_to_animal_products.csv",
    params:
        wirsenius_regions=config["animal_products"]["wirsenius_regions"],
        net_to_me_conversion=config["animal_products"][
            "net_to_metabolizable_energy_conversion"
        ],
        carcass_to_retail=config["animal_products"]["carcass_to_retail_meat"],
    log:
        "logs/{name}/build_feed_to_animal_products.log",
    script:
        "scripts/build_feed_to_animal_products.py"


rule calculate_manure_emissions:
    input:
        ruminant_feed_categories="processing/{name}/ruminant_feed_categories.csv",
        monogastric_feed_categories="processing/{name}/monogastric_feed_categories.csv",
        b0_data="data/ipcc_manure_methane_producing_capacity.csv",
        mcf_data="data/ipcc_manure_methane_conversion_factors.csv",
        mms_fractions="data/gleam_tables/manure_management_systems_fraction.csv",
    output:
        "processing/{name}/manure_ch4_emission_factors.csv",
    log:
        "logs/{name}/calculate_manure_emissions.log",
    script:
        "scripts/calculate_manure_emissions.py"


rule build_regions:
    input:
        world="processing/shared/gadm-simplified.gpkg",
    params:
        n_regions=config["aggregation"]["regions"]["target_count"],
        allow_cross_border=config["aggregation"]["regions"]["allow_cross_border"],
        cluster_method=config["aggregation"]["regions"]["method"],
        countries=config["countries"],
    output:
        "processing/{name}/regions.geojson",
    log:
        "logs/{name}/build_regions.log",
    script:
        "scripts/build_regions.py"


rule prepare_gbd_mortality:
    input:
        gbd_mortality="data/manually_downloaded/IHME-GBD_2021-dealth-rates.csv",
    params:
        countries=config["countries"],
        causes=config["health"]["causes"],
        reference_year=config["health"]["reference_year"],
    output:
        mortality="processing/{name}/health/gbd_mortality_rates.csv",
    log:
        "logs/{name}/prepare_gbd_mortality.log",
    script:
        "scripts/prepare_gbd_mortality.py"


rule prepare_gdd_dietary_intake:
    input:
        gdd_dir="data/manually_downloaded/GDD-dietary-intake",
    params:
        countries=config["countries"],
        food_groups=config["food_groups"]["included"],
        reference_year=config["health"]["reference_year"],
        ssb_sugar_g_per_100g=config["health"]["ssb_sugar_g_per_100g"],
    output:
        diet="processing/{name}/gdd_dietary_intake.csv",
    log:
        "logs/{name}/prepare_gdd_dietary_intake.log",
    script:
        "scripts/prepare_gdd_dietary_intake.py"


rule prepare_food_loss_waste:
    input:
        m49="data/M49-codes.csv",
    params:
        countries=config["countries"],
        food_groups=config["food_groups"]["included"],
        health_reference_year=config["health"]["reference_year"],
    output:
        food_loss_waste="processing/{name}/food_loss_waste.csv",
    log:
        "logs/{name}/prepare_food_loss_waste.log",
    script:
        "scripts/prepare_food_loss_waste.py"


rule prepare_relative_risks:
    input:
        gbd_rr="data/manually_downloaded/IHME_GBD_2019_RELATIVE_RISKS_Y2020M10D15.XLSX",
    params:
        risk_factors=config["health"]["risk_factors"],
        causes=config["health"]["causes"],
        omega3_per_100g=config["health"]["omega3_per_100g_fish"],
        ssb_sugar_g_per_100g=config["health"]["ssb_sugar_g_per_100g"],
    output:
        relative_risks="processing/{name}/health/relative_risks.csv",
    log:
        "logs/{name}/prepare_relative_risks.log",
    script:
        "scripts/prepare_relative_risks.py"


rule prepare_life_table:
    input:
        wpp_life_table="data/downloads/WPP_life_table.csv.gz",
    params:
        reference_year=config["health"]["reference_year"],
    output:
        life_table="processing/{name}/health/life_table.csv",
    log:
        "logs/{name}/prepare_life_table.log",
    script:
        "scripts/prepare_life_table.py"


rule prepare_health_costs:
    input:
        regions="processing/{name}/regions.geojson",
        diet="processing/{name}/gdd_dietary_intake.csv",
        relative_risks="processing/{name}/health/relative_risks.csv",
        dr="processing/{name}/health/gbd_mortality_rates.csv",
        population="processing/{name}/population_age.csv",
        life_table="processing/{name}/health/life_table.csv",
    params:
        countries=config["countries"],
        health=config["health"],
    output:
        risk_breakpoints="processing/{name}/health/risk_breakpoints.csv",
        cluster_cause="processing/{name}/health/cluster_cause_baseline.csv",
        cause_log="processing/{name}/health/cause_log_breakpoints.csv",
        cluster_summary="processing/{name}/health/cluster_summary.csv",
        clusters="processing/{name}/health/country_clusters.csv",
        cluster_risk_baseline="processing/{name}/health/cluster_risk_baseline.csv",
    log:
        "logs/{name}/prepare_health_costs.log",
    script:
        "scripts/prepare_health_costs.py"


rule compute_resource_classes:
    input:
        yields=(
            [gaez_path("yield", "r", crop) for crop in config["crops"]]
            + [gaez_path("yield", "i", crop) for crop in config["crops"]]
        ),
        regions="processing/{name}/regions.geojson",
    params:
        resource_class_quantiles=config["aggregation"]["resource_class_quantiles"],
    output:
        classes="processing/{name}/resource_classes.nc",
    log:
        "logs/{name}/compute_resource_classes.log",
    script:
        "scripts/compute_resource_classes.py"


rule aggregate_class_areas:
    input:
        classes="processing/{name}/resource_classes.nc",
        sr=[gaez_path("suitability", "r", crop) for crop in config["crops"]],
        si=[gaez_path("suitability", "i", crop) for crop in config["crops"]],
        irrigated_share="data/downloads/gaez_land_equipped_for_irrigation_share.tif",
        regions="processing/{name}/regions.geojson",
    params:
        land_limit_dataset=config["aggregation"]["land_limit_dataset"],
    output:
        "processing/{name}/land_area_by_class.csv",
    log:
        "logs/{name}/aggregate_class_areas.log",
    script:
        "scripts/aggregate_class_areas.py"


def yield_and_suitability_for_crop(w):
    """Get input files for build_crop_yields rule.

    w.crop is the crop name (e.g., 'wheat')
    w.water_supply is 'i' or 'r'
    """
    crop = w.crop
    ws = w.water_supply
    yield_kind = (
        "actual_yield" if config["validation"]["use_actual_yields"] else "yield"
    )

    inputs = {
        "yield_raster": gaez_path(yield_kind, ws, crop),
        "suitability_raster": gaez_path("suitability", ws, crop),
        "growing_season_start_raster": gaez_path("growing_season_start", ws, crop),
        "growing_season_length_raster": gaez_path("growing_season_length", ws, crop),
    }
    if ws == "i":
        inputs["water_requirement_raster"] = gaez_path("water_requirement", ws, crop)
    return inputs


rule build_crop_yields:
    input:
        unpack(yield_and_suitability_for_crop),
        classes="processing/{name}/resource_classes.nc",
        regions="processing/{name}/regions.geojson",
        yield_unit_conversions="data/yield_unit_conversions.csv",
        moisture_content="data/crop_moisture_content.csv",
    params:
        use_actual_yields=config["validation"]["use_actual_yields"],
    output:
        "processing/{name}/crop_yields/{crop}_{water_supply}.csv",
    log:
        "logs/{name}/build_crop_yields_{crop}_{water_supply}.log",
    script:
        "scripts/build_crop_yields.py"


def harvested_area_inputs(w):
    crop = w.crop
    ws = w.water_supply
    return {
        "harvested_area_raster": gaez_path("harvested_area", ws, crop),
        "classes": "processing/{name}/resource_classes.nc",
        "regions": "processing/{name}/regions.geojson",
        "crop_mapping": "data/gaez_crop_code_mapping.csv",
        "faostat_production": "processing/{name}/faostat_crop_production.csv",
    }


rule build_harvested_area:
    input:
        unpack(harvested_area_inputs),
    output:
        "processing/{name}/harvested_area/{crop}_{water_supply}.csv",
    log:
        "logs/{name}/build_harvested_area_{crop}_{water_supply}.log",
    script:
        "scripts/build_harvested_area.py"


def multi_cropping_inputs(_wildcards):
    combos_cfg = config["multiple_cropping"]
    crops_by_supply: dict[str, set[str]] = {"r": set(), "i": set()}
    for combo_name, entry in combos_cfg.items():
        water_supplies = entry.get("water_supplies", ["r"])
        if isinstance(water_supplies, str):
            water_supplies = [water_supplies]
        for ws in water_supplies:
            crops_by_supply[ws].update(entry["crops"])
    inputs = {
        "classes": "processing/{name}/resource_classes.nc",
        "regions": "processing/{name}/regions.geojson",
        "yield_unit_conversions": "data/yield_unit_conversions.csv",
    }
    for ws in ("r", "i"):
        for crop in sorted(crops_by_supply[ws]):
            prefix = f"{crop}_{ws}"
            inputs[f"{prefix}_yield_raster"] = gaez_path("yield", ws, crop)
            inputs[f"{prefix}_suitability_raster"] = gaez_path("suitability", ws, crop)
            inputs[f"{prefix}_growing_season_start_raster"] = gaez_path(
                "growing_season_start", ws, crop
            )
            inputs[f"{prefix}_growing_season_length_raster"] = gaez_path(
                "growing_season_length", ws, crop
            )
            if ws == "i":
                inputs[f"{prefix}_water_requirement_raster"] = gaez_path(
                    "water_requirement", ws, crop
                )
        if crops_by_supply[ws]:
            inputs[f"multiple_cropping_zone_{ws}"] = gaez_path(
                "multiple_cropping_zone", ws, "all"
            )
    return inputs


rule build_multi_cropping:
    input:
        unpack(multi_cropping_inputs),
    params:
        combinations=lambda wildcards: config["multiple_cropping"],
        use_actual_yields=config["validation"]["use_actual_yields"],
    output:
        eligible="processing/{name}/multi_cropping/eligible_area.csv",
        yields="processing/{name}/multi_cropping/cycle_yields.csv",
    log:
        "logs/{name}/build_multi_cropping.log",
    script:
        "scripts/build_multi_cropping.py"


rule build_grassland_yields:
    input:
        grassland="data/downloads/grassland_yield_historical.nc4",
        classes="processing/{name}/resource_classes.nc",
        regions="processing/{name}/regions.geojson",
    output:
        "processing/{name}/grassland_yields.csv",
    log:
        "logs/{name}/build_grassland_yields.log",
    script:
        "scripts/build_grassland_yields.py"


rule extract_waterfootprint_appendix:
    input:
        zip_path="data/downloads/Report53_Appendix.zip",
    output:
        shapefile="data/downloads/Report53_Appendix/Report53-BlueWaterScarcity-ArcGIS-ShapeFile/Monthly_WS_GRDC_405_basins.shp",
        excel="data/downloads/Report53_Appendix/Report53-Appendices-VI-IX.xls",
    log:
        "logs/shared/extract_waterfootprint_appendix.log",
    shell:
        r"""
        unzip -o {input.zip_path} -d data/downloads > {log} 2>&1
        """


rule process_blue_water_availability:
    input:
        shapefile=rules.extract_waterfootprint_appendix.output.shapefile,
        excel=rules.extract_waterfootprint_appendix.output.excel,
    output:
        "processing/{name}/water/blue_water_availability.csv",
    log:
        "logs/{name}/process_blue_water_availability.log",
    script:
        "scripts/process_blue_water_availability.py"


def crop_yield_file_list(w):
    return list(yield_inputs(w).values())


rule build_region_water_availability:
    input:
        shapefile=rules.extract_waterfootprint_appendix.output.shapefile,
        regions="processing/{name}/regions.geojson",
        monthly="processing/{name}/water/blue_water_availability.csv",
        crop_yields=crop_yield_file_list,
    output:
        monthly_region="processing/{name}/water/monthly_region_water.csv",
        region_growing="processing/{name}/water/region_growing_season_water.csv",
    log:
        "logs/{name}/build_region_water_availability.log",
    script:
        "scripts/build_region_water_availability.py"


def yield_inputs(wildcards):
    """Get all crop yield files for model building."""
    irr_cfg = config["irrigation"]["irrigated_crops"]
    if irr_cfg == "all":
        irrigated_crops = config["crops"]
    else:
        irrigated_crops = list(irr_cfg)

    return {
        f"{crop}_yield_{water_supply}": f"processing/{{name}}/crop_yields/{crop}_{water_supply}.csv"
        for crop, water_supply in (
            list(zip(config["crops"], itertools.repeat("r")))  # Rainfed
            + list(zip(irrigated_crops, itertools.repeat("i")))
        )
    }


def harvested_area_model_inputs(_wildcards):
    """Return harvested area files when actual production mode is enabled."""

    if not config["validation"]["use_actual_production"]:
        return {}

    irr_cfg = config["irrigation"]["irrigated_crops"]
    if irr_cfg == "all":
        irrigated_crops = config["crops"]
    else:
        irrigated_crops = list(irr_cfg)

    inputs = {
        f"{crop}_harvested_r": f"processing/{{name}}/harvested_area/{crop}_r.csv"
        for crop in config["crops"]
    }
    for crop in irrigated_crops:
        inputs[f"{crop}_harvested_i"] = (
            f"processing/{{name}}/harvested_area/{crop}_i.csv"
        )
    return inputs


rule build_crop_residue_yields:
    input:
        yield_r=lambda wildcards: f"processing/{wildcards.name}/crop_yields/{wildcards.crop}_r.csv",
        yield_i=lambda wildcards: (
            f"processing/{wildcards.name}/crop_yields/{wildcards.crop}_i.csv"
            if config["irrigation"]["irrigated_crops"] == "all"
            or wildcards.crop in config["irrigation"]["irrigated_crops"]
            else []
        ),
        gleam_supplement="data/downloads/gleam_3.0_supplement_s1.xlsx",
        ruminant_feed_table="data/gleam_tables/ruminants_feed_yield_fractions.csv",
        monogastric_feed_table="data/gleam_tables/monogastrics_feed_yeild_fractions.csv",
        regions="processing/{name}/regions.geojson",
    output:
        "processing/{name}/crop_residue_yields/{crop}.csv",
    log:
        "logs/{name}/build_crop_residue_yields_{crop}.log",
    script:
        "scripts/build_crop_residue_yields.py"


def residue_yield_inputs(_wildcards):
    return {
        f"residue_{crop}": f"processing/{{name}}/crop_residue_yields/{crop}.csv"
        for crop in (
            set(config["animal_products"]["residue_crops"]) & set(config["crops"])
        )
    }


rule build_model:
    input:
        unpack(yield_inputs),
        unpack(residue_yield_inputs),
        unpack(harvested_area_model_inputs),
        fertilizer_n_rates="processing/{name}/global_fertilizer_n_rates.csv",
        foods="data/foods.csv",
        moisture_content="data/crop_moisture_content.csv",
        ruminant_feed_categories="processing/{name}/ruminant_feed_categories.csv",
        ruminant_feed_mapping="processing/{name}/ruminant_feed_mapping.csv",
        monogastric_feed_categories="processing/{name}/monogastric_feed_categories.csv",
        monogastric_feed_mapping="processing/{name}/monogastric_feed_mapping.csv",
        feed_to_products="processing/{name}/feed_to_animal_products.csv",
        manure_ch4_emissions="processing/{name}/manure_ch4_emission_factors.csv",
        food_groups="data/food_groups.csv",
        nutrition="data/nutrition.csv",
        regions="processing/{name}/regions.geojson",
        land_area_by_class="processing/{name}/land_area_by_class.csv",
        multi_cropping_area="processing/{name}/multi_cropping/eligible_area.csv",
        multi_cropping_yields="processing/{name}/multi_cropping/cycle_yields.csv",
        edible_portion="processing/{name}/fao_edible_portion.csv",
        population="processing/{name}/population.csv",
        baseline_diet="processing/{name}/gdd_dietary_intake.csv",
        food_loss_waste="processing/{name}/food_loss_waste.csv",
        costs="processing/{name}/crop_costs.csv",
        grassland_yields="processing/{name}/grassland_yields.csv",
        monthly_region_water="processing/{name}/water/monthly_region_water.csv",
        growing_season_water="processing/{name}/water/region_growing_season_water.csv",
        blue_water_availability="processing/{name}/water/blue_water_availability.csv",
        luc_carbon_coefficients="processing/{name}/luc/luc_carbon_coefficients.csv",
        current_grassland_area="processing/{name}/luc/current_grassland_area_by_class.csv",
        grazing_only_land="processing/{name}/land_grazing_only_by_class.csv",
    params:
        crops=config["crops"],
        multiple_cropping=config["multiple_cropping"],
        countries=config["countries"],
        primary=config["primary"],
        biomass=config["biomass"],
        emissions=config["emissions"],
        food_groups=config["food_groups"]["included"],
        food_group_constraints=config["food_groups"].get("constraints", {}),
        macronutrients=config["macronutrients"],
        diet=config["diet"],
        byproducts=config["byproducts"],
        animal_products=config["animal_products"],
        trade=config["trade"],
        grazing=grazing_cfg,
        health_reference_year=config["health"]["reference_year"],
    output:
        network="results/{name}/build/model.nc",
    log:
        "logs/{name}/build_model.log",
    script:
        "scripts/build_model.py"


def solve_model_inputs(w):
    """Get input files for solve_model rule.

    Includes validation-specific inputs (e.g., FAO animal production data)
    only when validation mode is enabled.
    """
    inputs = {
        "network": f"results/{w.name}/build/model.nc",
        "health_risk_breakpoints": f"processing/{w.name}/health/risk_breakpoints.csv",
        "health_cluster_cause": f"processing/{w.name}/health/cluster_cause_baseline.csv",
        "health_cause_log": f"processing/{w.name}/health/cause_log_breakpoints.csv",
        "health_cluster_summary": f"processing/{w.name}/health/cluster_summary.csv",
        "health_clusters": f"processing/{w.name}/health/country_clusters.csv",
        "population": f"processing/{w.name}/population.csv",
        "food_groups": "data/food_groups.csv",
    }

    # Add validation-specific inputs
    if config.get("validation", {}).get("use_actual_production", False):
        inputs["animal_production"] = (
            f"processing/{w.name}/faostat_animal_production.csv"
        )

    return inputs


rule solve_model:
    input:
        unpack(solve_model_inputs),
    params:
        health_risk_factors=config["health"]["risk_factors"],
        health_value_per_yll=config["health"]["value_per_yll"],
        solver=config["solving"]["solver"],
        solver_options=config["solving"].get(
            f"options_{config['solving']['solver']}", {}
        ),
    output:
        network="results/{name}/solved/model.nc",
    log:
        "logs/{name}/solve_model.log",
    script:
        "scripts/solve_model.py"
